#!/bin/zsh

.autocomplete.async.precmd() {
  emulate -L zsh -o extendedglob
  add-zsh-hook -d precmd .autocomplete.async.precmd

  zmodload -Fa zsh/zpty b:zpty
  zmodload -Fa zsh/system p:sysparams
  zmodload -Fa zsh/zutil b:zparseopts

  builtin autoload -Uz .autocomplete.highlight .autocomplete.zle-flags

  typeset -gHF _autocomplete__async_avg_duration=0.3

  typeset -gHi _autocomplete__async_complete_fd _autocomplete__async_complete_pid
  zle -N .autocomplete.async.complete.fd-widget

  typeset -gHi _autocomplete__async_timeout_fd _autocomplete__async_timeout_pid
  zle -N .autocomplete.async.timeout.fd-widget

  zle -C .autocomplete.list-choices list-choices .autocomplete.async.list-choices.completion-widget

  if [[ -v functions[_zsh_highlight_call_widget] ]]; then
    _zsh_highlight_call_widget() {
      .autocomplete.zle-flags $WIDGET
      builtin zle "$@"
    }
  fi

  typeset -gHi ZSH_AUTOSUGGEST_USE_ASYNC=1
  if [[ -v functions[_zsh_autosuggest_highlight_apply] ]]; then
    local action
    for action in clear modify fetch suggest accept partial_accept execute enable disable toggle
    do
      eval "_zsh_autosuggest_widget_$action() {
        .autocomplete.zle-flags \$WIDGET
        _zsh_autosuggest_$action \$@
      }"
    done
  fi

  add-zle-hook-widget line-pre-redraw .autocomplete.async.line-pre-redraw
  add-zle-hook-widget line-finish .autocomplete.async.stop
  add-zsh-hook zshexit .autocomplete.async.stop
}

.autocomplete.async.line-pre-redraw() {
  .autocomplete.zle-flags $LASTWIDGET

  if (( KEYS_QUEUED_COUNT + PENDING > 0 )); then
    .autocomplete.async.stop
    return 0
  fi

  [[ -v functions[_zsh_highlight] ]] &&
    _zsh_highlight
  typeset -gHa _autocomplete__highlight=( $region_highlight[@] )

  [[ -v functions[_zsh_autosuggest_highlight_apply] ]] &&
    _zsh_autosuggest_highlight_apply

  if [[ $LASTWIDGET == list-expand ||
      -n $MENUSELECT && $LASTWIDGET == .autocomplete.async.timeout.fd-widget ]]; then
    .autocomplete.async.stop
    return 0
  fi

  .autocomplete.async.start
  return 0
}

.autocomplete.async.stop() {
  emulate -L zsh

  .autocomplete.async.kill $_autocomplete__async_complete_fd $_autocomplete__async_complete_pid
  _autocomplete__async_complete_fd=0
  _autocomplete__async_complete_pid=0

  .autocomplete.async.kill $_autocomplete__async_timeout_fd $_autocomplete__async_timeout_pid
  _autocomplete__async_timeout_fd=0
  _autocomplete__async_timeout_pid=0

  unset _autocomplete__words _autocomplete__current
}

.autocomplete.async.kill() {
  emulate -L zsh

  local -i fd=$1 pid=$2

  if (( fd > 9 )) && { : <&$fd } 2>/dev/null; then
    # Close the file descriptor and remove the handler widget.
    exec {fd}<&-
    zle -F $fd 2>/dev/null
  fi

  if (( pid != 0 )); then
    # Zsh will make a new process group for the child process only if job control is enabled.
    local group=''; [[ -o MONITOR ]] &&
      group='-'
    kill -TERM $group$pid 2>/dev/null
  fi
}

.autocomplete.async.start() {
  typeset -F SECONDS=0

  .autocomplete.async.kill $_autocomplete__async_complete_fd $_autocomplete__async_complete_pid
  exec {_autocomplete__async_complete_fd}< <(
    setopt extendedglob noxtrace noverbose

    local pid=$sysparams[pid]
    print $pid
    {
      local REPLY
      zpty _autocomplete__zpty .autocomplete.async.complete.inner '$LBUFFER' '$RBUFFER'
      zpty -w _autocomplete__zpty $'\t'

      local line
      zpty -r _autocomplete__zpty line '*'$'\0'$'\0'
      zpty -r _autocomplete__zpty line '*'$'\0'$'\0'
      print -rNC1 - "$SECONDS" "$pid" "$line"
    } always {
      zpty -d _autocomplete__zpty
      kill -TERM $pid
    }
  )
  read _autocomplete__async_complete_pid <&$_autocomplete__async_complete_fd
  zle -Fw "$_autocomplete__async_complete_fd" .autocomplete.async.complete.fd-widget

  .autocomplete.async.kill $_autocomplete__async_timeout_fd $_autocomplete__async_timeout_pid
  exec {_autocomplete__async_timeout_fd}< <(
      setopt extendedglob noxtrace noverbose

      local complete_pid=$_autocomplete__async_complete_pid
      local complete_fd=$_autocomplete__async_complete_fd
      local pid=$sysparams[pid]
      print $pid
    {
      sleep $(( max(0, 2 * _autocomplete__async_avg_duration - SECONDS) ))
      print -rNC1 - "$pid" "$complete_fd" "$complete_pid"
    } always {
      kill -TERM $pid
    }
  )
  read _autocomplete__async_timeout_pid <&$_autocomplete__async_timeout_fd
  zle -Fw "$_autocomplete__async_timeout_fd" .autocomplete.async.timeout.fd-widget

  # There's a weird bug in Zsh < 5.8, where where ^C stops working unless we force a fork.
  # See https://github.com/zsh-users/zsh-autosuggestions/issues/364
  command true
}

.autocomplete.async.complete.inner() {
  setopt extendedglob nobanghist noxtrace noverbose

  local hooks=( chpwd periodic precmd preexec zshaddhistory zshexit zsh_directory_name )
  unset ${^hooks}_functions &>/dev/null
  $hooks[@] () { : }
  .autocomplete.no-op() { : }
  local hook; for hook in isearch-exit isearch-update line-pre-redraw line-init line-finish \
      history-line-set keymap-select; do
    zle -N zle-$h .autocomplete.no-op
  done

  typeset -gH lbuffer=$1 rbuffer=$2

  complete-word() {
    LBUFFER=$lbuffer
    RBUFFER=$rbuffer
    zle list-choices -w
  }

  message() {
    typeset -gH _message_=$mesg
  }

  list-choices() {
    local curcontext=$curcontext; [[ -z $curcontext ]] &&
      curcontext=list-choices:::

    unset 'compstate[vared]'
    local +h -a comppostfuncs=( message )
    {
      .autocomplete.async.list-choices.complete
      print -rNC1 - '' '' "$compstate[nmatches]" "$CURRENT" "${(q+)words}" "${(q+)_message_}" ''
    } always {
      compstate[insert]=''
      compstate[list]=''
      compstate[list_max]=0
    }
  }

  zle -N complete-word
  zle -C list-choices list-choices list-choices
  bindkey '^I' complete-word
  local __tmp__
  vared __tmp__
}

.autocomplete.async.complete.fd-widget() {
  local -F seconds
  local -i pid nmatches current
  local debug _words_ message eof

  {
    [[ -z $2 || $2 == hup ]] &&
      IFS=$'\0' read -r seconds pid nmatches current _words_ message eof <&$1
  } always {
    .autocomplete.async.kill $1 $pid
  }
  if (( $1 == $_autocomplete__async_complete_fd &&
      $pid == $_autocomplete__async_complete_pid )); then
    _autocomplete__async_complete_fd=0
    _autocomplete__async_complete_pid=0
  fi

  (( _autocomplete__async_avg_duration = .1 * seconds + .9 * _autocomplete__async_avg_duration ))

  .autocomplete.zle-flags ||
    return 0

  _words_="${(Q)_words_}"
  [[ -v _autocomplete__words && $_autocomplete__words == $_words_ &&
      -v _autocomplete__current && $_autocomplete__current -eq $current ]] &&
    return 0

  # If a widget can't be called, ZLE always returns true.
  # Thus, we return false on purpose, so we can check if our widget got called.
  setopt localoptions NO_banghist NO_completeinword
  if ! zle .autocomplete.list-choices -w "$nmatches" "${(Q)message}" 2>/dev/null
  then
    typeset -gH _autocomplete__words=$_words_
    typeset -gHi _autocomplete__current=$current
    region_highlight=( "$_autocomplete__highlight[@]" )
    [[ -v functions[_zsh_autosuggest_highlight_apply] ]] &&
      _zsh_autosuggest_highlight_apply

    # Refresh if and only if our widget got called. Otherwise, ZLE will crash (eventually).
    zle -R
  fi
  return 0
}

.autocomplete.async.list-choices.completion-widget() {
  setopt localoptions extendedglob

  local curcontext=$curcontext; [[ -z $curcontext ]] &&
    curcontext=list-choices:::

  local -i nmatches=$1
  local message=$2

  local min_input; zstyle -s :autocomplete: min-input min_input ||
    min_input=1
  local ignored; zstyle -s :autocomplete: ignored-input ignored ||
    ignored=' '

  if (( nmatches == 0 )) && [[ -n $message ]]; then
    local msg
    zformat -f msg "$message"
    compadd -x "$msg"
  elif [[ $words[CURRENT] != $~ignored ]] && (( CURRENT > 1 || $#words[1] >= min_input )); then
    .autocomplete.async.list-choices.complete
  fi

  compstate[insert]=''
  _lastcomp[insert]=''
  compstate[list_max]=0
  unset MENUSELECT
  return 2
}

.autocomplete.async.list-choices.complete() {
  {
    local -i _autocomplete__max_lines=$(( _autocomplete__max_lines() ))
    functions[compadd]=$functions[.autocomplete.async.compadd]
    _main_complete
  } always {
    [[ -v functions[compadd] ]] &&
      unfunction compadd
    [[ -v functions[comptags] ]] &&
      unfunction comptags
  }
}

.autocomplete.async.compadd() {
  setopt localoptions listtypes

  if [[ $funcstack[2] ==
      _autocomplete.(alias_expansions|history_lines|requoted|unambiguous) ]]; then
    .autocomplete.compadd "$@"
    return
  fi

  local -a _opts_=()
  zparseopts -E -A _opts_ - D: E: x: X:

  if [[ -v _opts_[-E] || -v _opts_[-x] ]]; then
    .autocomplete.compadd "$@"
    return
  fi

  local -a _matches_=()
  local -i extras=2 header=$+_opts_[-X] lines_of_new_matches ret
  local -i lines_available=$((
    max(0, _autocomplete__max_lines - header - compstate[list_lines] - extras) ))

  if [[ -v _opts_[-D] ]]; then
    .autocomplete.compadd "$@"; ret=$?

    [[ $funcstack[2] == _describe ]] ||
      return ret

    local array_name=$_opts_[-D]

    (( ${${(PA)array_name}[(I)*:*]} > 0 )) ||
      return

    local -aU uniques=( ${${(P@)array_name}#*:} )
    _matches_=( ${(P@)array_name} )
    lines_of_new_matches=$#uniques[@]
    (( lines_available -= _autocomplete__reserved_lines ))
  else
    _autocomplete__reserved_lines=0
    local -i fd list_lines=0
    {
      exec {fd}< <(
        _opts_=()
        zparseopts -D -E -A _opts_ - A: D: O: X:
        builtin compadd -O _matches_ "$@"

        zparseopts -D -E -A _opts_ - a
        _autocomplete.compadd_opts_len "$@"
        .autocomplete.compadd "${(@)@[1,?]}" -U -a _matches_

        print $compstate[list_lines]
        print -r - ${(pj:\0:)_matches_}
      )
      IFS=$'\0' read list_lines <&$fd
      IFS=$'\0' read -A _matches_ <&$fd
    } always {
      exec {fd}<&-
    }
    _matches_=( $_matches_[@] )  # Filter out blanks.
    lines_of_new_matches=$(( list_lines - compstate[list_lines] ))
  fi

  if (( lines_of_new_matches <= lines_available )); then
    if [[ $funcstack[2] == _describe && -v _opts_[-D] ]]; then
      (( _autocomplete__reserved_lines += $lines_of_new_matches ))
      return ret
    fi
    .autocomplete.compadd "$@"
    return
  fi

  local info hint=$'%{\e[02;39m%}' kbd=$'%{\e[22;39m%}' end=$'%{\e[0m%}'
  zstyle -s ":autocomplete:${curcontext}:too-many-matches" message info ||
    info="${hint}(partial list; press ${kbd}Ctrl${hint}+${kbd}Space$hint to expand)$end"
  (( lines_available-- ))

  if [[ -v _opts_[-D] ]]; then
    local -i trim=$(( $#uniques - max(0, lines_available) ))
    if (( trim > 0 )); then
      shift -p $trim uniques
      set -A $array_name ${(M@)${(P@)array_name}:#*:(${(~j:|:)uniques})}
      builtin compadd -x $info
    fi
    (( _autocomplete__reserved_lines += $#uniques ))
    (( ${(P@)#array_name} > 0 ))
    return
  fi

  zparseopts -D -E -A _opts_ - a d: k l U
  local -a dopt=()
  if [[ -v _opts_[-d] ]]; then
    if [[ -v _opts_[-l] ]]; then
      dopt+=( -ld )
    else
      dopt+=( -d )
    fi
    dopt+=( "$_opts_[-d]" )
  fi
  if (( lines_of_new_matches > 0 )); then
    local -F matches_per_line=$(( 1.0 * $#_matches_ / lines_of_new_matches ))
    if (( matches_per_line < 1 )); then
      dopt[1]=-ld
      array_name=$_opts_[-d]
      if [[ -z $array_name ]]; then
        array_name=displ
        local -a displ=( "$_matches_[@]" )
        dopt[2]=displ
      fi
      set -A $array_name ${(r:COLUMNS-1:@)${(P@)array_name}//$'\n'/\n}
      matches_per_line=1
    fi
      local -i trim=$(( $#_matches_ - max(0, matches_per_line * lines_available) ))
      if (( trim > 0 && $#_matches_ > 0 )); then
        shift -p $trim _matches_
        (( $#_matches_ > 0 )) ||
          comptags() {
            [[ $funcstack[3] ==
                _autocomplete.(alias_expansions|history_lines|requoted|unambiguous) ]] ||
              return 1
            builtin comptags "$@"
          }
        builtin compadd -x $info
      fi
    fi
  _autocomplete.compadd_opts_len "$@"
  .autocomplete.compadd "${(@)@[1,?]}" $dopt -U -a _matches_
}

.autocomplete.async.timeout.fd-widget() {
  local -i pid complete_fd complete_pid
  local eof
  {
    [[ -z $2 || $2 == hup ]] &&
      IFS=$'\0' read -r pid complete_fd complete_pid eof <&$1
  } always {
    .autocomplete.async.kill $1 $pid
  }

  .autocomplete.zle-flags ||
    return 0

  (( $complete_fd == $_autocomplete__async_complete_fd &&
      $complete_pid == $_autocomplete__async_complete_pid )) ||
    return

  (( _autocomplete__async_avg_duration *= 1.2 ))
  .autocomplete.async.start
}

add-zsh-hook precmd .autocomplete.async.precmd
