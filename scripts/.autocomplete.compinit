#!/bin/zsh
zmodload -Fa zsh/files b:zf_rm
zmodload -F zsh/parameter p:funcstack p:functions

typeset -gHa _autocomplete__compdef=()
compdef() {
  typeset -gHa _autocomplete__compdef=( $_autocomplete__compdef[@] "${(j: :)${(@q+)@}}" )
}

[[ -v functions[_bash_complete] ]] ||
    _bash_complete compgen complete () {
      unfunction _bash_complete compgen complete
      builtin autoload +X -Uz bashcompinit
      bashcompinit
      bashcompinit() { : }
      ${(%):-%N} "$@"
    }

.autocomplete.compinit.precmd() {
  emulate -L zsh
  setopt $_autocomplete__func_opts[@]

  [[ -v CDPATH && -z $CDPATH ]] &&
      unset CDPATH cdpath

  # Decrease Oh My Zsh start-up time. See below.
  local -Pa omzdump=()
  [[ -v ZSH_COMPDUMP && -r $ZSH_COMPDUMP ]] &&
      omzdump=( ${(f)"$( < $ZSH_COMPDUMP )"} )

  typeset -gU FPATH fpath=( ~zsh-autocomplete/functions/completion $fpath[@] )
  typeset -gH \
      _comp_dumpfile=${_comp_dumpfile:-${ZSH_COMPDUMP:-${XDG_CACHE_HOME:-$HOME/.cache}/zsh/compdump}}

  if [[ -v _comps[-command-] && $_comps[-command-] != _autocomplete.command ]]; then
    zf_rm -f $_comp_dumpfile
  else
    local -Pa compfuncfiles=( ~zsh-autocomplete/functions/completion/_autocomplete.*~*.zwc(N-.) )

    if ! (( $#compfuncfiles )); then
      print -u2 -- 'autocomplete: Failed to find completion function files. Aborting.'
      return 66
    fi

    # Check if any of our function files are newer than the comp dump file.
    local -P f=
    for f in $compfuncfiles[@]; do
      if [[ -v functions[$f:t] && $f -nt $_comp_dumpfile ]]; then
        zf_rm -f $_comp_dumpfile
        break
      fi
    done
  fi

  if ! [[ -v _comp_setup && -r $_comp_dumpfile ]]; then
    unfunction compdef compinit 2> /dev/null
    bindkey() { : }
    {
      builtin autoload +X -Uz compinit
      compinit -d $_comp_dumpfile
    } always {
      unfunction bindkey
    }

    # Prevent Oh My Zsh from deleting comp dump file.
    (( ${#omzdump[@]} > 0 )) &&
      tee -a "$ZSH_COMPDUMP" &> /dev/null <<EOF
$omzdump[-2]
$omzdump[-1]
EOF
  fi

  compinit() { : }

  local -P args=
  for args in "$_autocomplete__compdef[@]"; do
    eval "compdef $args"
  done
  unset _autocomplete__compdef

  (
    local -a reply=()
    local cache_dir=
    if builtin zstyle -s ':completion:*' cache-path cache_dir; then
      local -P src= bin=
      for src in $cache_dir/*~**.zwc~**/.*(N-.); do
        bin=$src.zwc
        if [[ ! -e $bin || $bin -ot $src ]]; then
          zcompile -Uz $src
        fi
      done
    fi
  ) &|

  # Workaround: Some other plugins rely on patching _main_complete, which can interfere with our completion.
  functions[autocomplete:tmp]="$functions[_main_complete]"
  .autocomplete.patch _main_complete
  functions[_main_complete]="$functions[autocomplete:tmp]"
  unfunction autocomplete:tmp

  autocomplete:new:_main_complete() {
    local -i _autocomplete__reserved_lines=0
    local -Pi ret=1
    unset _autocomplete__partial_list _autocomplete__unambiguous

    compstate[insert]=menu  # To get the best output from `_expand` (and some other functions).
    compstate[last_prompt]=yes  # Completion doesn't stay on the same command line without this.
    compstate[list]='list force packed rows' # `_setup` doesn't work well for this.
    unset 'compstate[vared]'

    [[ -v functions[compadd] ]] ||
        functions[compadd]=$functions[.autocomplete.compadd]

    local +h -a comppostfuncs=( autocomplete:new:_main_complete.post "$comppostfuncs[@]" )
    autocomplete:old:_main_complete "$@"
  }

  # Add support for coloring file types to _expand.
  # TODO: Might be added a future version of zsh.
  .autocomplete.compadd() {
    if [[ $_completer == expand* ]]; then
      [[ $@[-1] == space && $#space[@] -eq 1 ]] &&
          space=( ${(q+)${(Q)space}} )
      builtin compadd -fW "${${${words[CURRENT]:#[~/]*}:+$PWD/}:-/}" "$@"
    else
      builtin compadd "$@"
    fi
  }

  autocomplete:new:_main_complete.post() {
    [[ $WIDGET != _complete_help ]] &&
        unfunction compadd 2> /dev/null
    _autocomplete.unambiguous
    compstate[list_max]=0
    MENUSCROLL=0
  }

  .autocomplete.patch _expand
  _expand() {
    if _autocomplete.is_glob; then
      compstate[pattern_insert]=   # compstate[insert]=unambiguous won't work without this.
      compstate[pattern_match]=\*  # Append * to the pattern.

      autocomplete:old:_expand "$@"
      return
    fi

    autocomplete:old:_expand "$@"
  }

  .autocomplete.patch _complete
  _complete() {
    local -i nmatches=$compstate[nmatches]

    PREFIX=$PREFIX$SUFFIX
    SUFFIX=
    autocomplete:old:_complete "$@" ||
        _autocomplete.ancestor_dirs "$@" ||
            _autocomplete.recent_paths "$@"

    # Work around the fact that some completion functions mistakenly don't
    # return 0 when they have succeeded.
    (( compstate[nmatches] > nmatches ))
  }

  .autocomplete.patch _approximate
  _approximate() {
    [[ -z $words[CURRENT] || -v compstate[quote] ]] &&
        return 1
    [[ -o banghist && $words[CURRENT] == [$histchars]* ]] &&
        return 1
    _autocomplete.is_glob &&
        return 1

    local -Pi ret=1
    {
      [[ -v functions[compadd] ]] &&
        functions[.autocomplete.__tmp__]=$functions[compadd]

      compadd() {
        local -P ppre="$argv[(I)-p]"

        [[ ${argv[(I)-[a-zA-Z]#U[a-zA-Z]#]} -eq 0 && "${#:-$PREFIX$SUFFIX}" -le _comp_correct ]] &&
            return

        if [[ "$PREFIX" = \~* && ( ppre -eq 0 || "$argv[ppre+1]" != \~* ) ]]; then
          PREFIX="~(#a$_comp_correct)$PREFIX[2,-1]"
        else
          PREFIX="(#a$_comp_correct)$PREFIX"
        fi

        builtin compadd "$@"
      }

      autocomplete:old:_approximate "$@"
      ret=$?
      _lastdescr=( ${_lastdescr[@]:#corrections} )
    } always {
      [[ -v functions[compadd] ]] &&
          unfunction compadd
      if [[ -v functions[.autocomplete.__tmp__] ]]; then
        functions[compadd]=$functions[.autocomplete.__tmp__]
        unfunction .autocomplete.__tmp__
      fi
    }
    return ret
  }

  # Let parameter completion list each parameter's value.
  # TODO: Might be added to a future version of zsh.
  .autocomplete.patch _wanted
  _wanted() {
    if [[ $funcstack == *_parameters* ]] &&
        builtin zstyle -T ":completion:${curcontext}:parameters" verbose; then
      local -a params=( $@[(re)-,-1] )
      shift -p $#params
      shift params
      _description "$@[1,3]"
      builtin compadd "$expl[@]" "$@[5,-1]" -D params -a params
      local -a displays=()

      local sep=
      builtin zstyle -s ":completion:${curcontext}:parameters" list-separator sep ||
          sep=--

      local -Pi MBEGIN= MEND=
      local -P MATCH=
      zformat -a displays " $sep " \
          "${(@)params[@]:/(#m)*/${MATCH}:${${(kv)${(P)MATCH}}[1,COLUMNS]}}"
      displays=( "${(@)displays[@]//(#m)[^[:print:]]##/${(q+)MATCH}}" )
      displays=( "${(@)displays[@]:/(#m)*/$MATCH[1,COLUMNS]}" )
      autocomplete:old:_wanted "$@" -d displays -a params
    else
      autocomplete:old:_wanted "$@"
    fi
  }
}
