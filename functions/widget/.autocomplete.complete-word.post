#autoload
builtin autoload -Uz is-at-least

unset MENUSELECT
compstate[insert]=

private key_name=
case $KEYS in
  ( $'\t'           ) key_name=tab ;;
  ( $terminfo[kcbt] ) key_name=shift-tab ;;
esac
local key_style=
builtin zstyle -s :autocomplete:${key_name}: widget-style key_style

if  [[ ! -v compstate[old_list] || -z $compstate[old_list] ]] ||
    (
      [[ -v _autocomplete__unambiguous && -n $_autocomplete__unambiguous ]] &&
      builtin zstyle -t ":autocomplete:${key_name}:" insert-unambiguous
    ); then

  if ! is-at-least 5.8.1; then
    # Work around a crashing bug in Zsh.
    # See [zsh-workers 48936](https://www.zsh.org/mla/workers/2021/msg01162.html).
    [[ $key_style == *menu-* && -n $key_name ]] &&
        compstate[insert]='automenu-'
  fi

  compstate[insert]+=unambiguous
  compstate[list]='list force packed rows'
  unset _autocomplete__unambiguous
  return
fi

if [[ $WIDGET == *menu-select ]]; then
  # Determine which terminal line we're on (for async completion).
  typeset -gHi _autocomplete__buffer_start_line=$((
      max( min( _autocomplete__buffer_start_line, LINES - compstate[list_lines] ), BUFFERLINES )
  ))
  typeset -gHi MENUSELECT=0
fi

if ! is-at-least 5.8.1; then
  # Work around a crashing bug in Zsh.
  # See [zsh-workers 48936](https://www.zsh.org/mla/workers/2021/msg01162.html).
  [[ $key_style == *menu-* && -n $key_name ]] &&
      compstate[insert]='menu:'
fi

if [[ $key_name == shift-tab ]]; then
  compstate[insert]+='0'
else
  compstate[insert]+='1'
fi

local -a tags=() match=() mbegin=() mend=()
builtin zstyle -a :autocomplete: add-space tags ||
    tags=( executables aliases functions builtins reserved-words commands )

[[ $RBUFFER != [[:space:]]* && -n ${${=${_comp_tags:-$_lastcomp[tags]}}:*tags} ]] &&
    compstate[insert]+=' '
